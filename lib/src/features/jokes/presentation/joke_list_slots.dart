// import 'dart:async';

// import 'package:flutter/material.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:snickerdoodle/src/core/services/analytics_service.dart';
// import 'package:snickerdoodle/src/core/services/app_logger.dart';
// import 'package:snickerdoodle/src/core/services/app_usage_service.dart';
// import 'package:snickerdoodle/src/features/jokes/application/joke_data_providers.dart';

// typedef InjectedSlotBuilder =
//     Widget Function(BuildContext context, InjectedSlotRenderData data);

// /// Metadata supplied to injected slot builders when rendered.
// class InjectedSlotRenderData {
//   const InjectedSlotRenderData({
//     required this.slotIndex,
//     required this.realJokesBefore,
//     required this.totalJokes,
//     required this.hasMore,
//     required this.isLoading,
//   });

//   final int slotIndex;
//   final int realJokesBefore;
//   final int totalJokes;
//   final bool hasMore;
//   final bool isLoading;
// }

// /// Represents a slot rendered by [JokeListViewer].
// sealed class JokeListSlot {
//   const JokeListSlot({required this.slotIndex});

//   /// Zero-based index within the rendered sequence.
//   final int slotIndex;
// }

// /// Slot that renders an actual joke.
// class JokeSlot extends JokeListSlot {
//   JokeSlot({
//     required super.slotIndex,
//     required this.jokeIndex,
//     required this.joke,
//   });

//   final int jokeIndex;
//   final JokeWithDate joke;
// }

// /// Slot generated by an injection strategy.
// class InjectedSlot extends JokeListSlot {
//   InjectedSlot({
//     required super.slotIndex,
//     required this.id,
//     required this.realJokesBefore,
//     required this.builder,
//     required this.totalJokes,
//     required this.hasMore,
//     required this.isLoading,
//   });

//   final String id;
//   final int realJokesBefore;
//   final InjectedSlotBuilder builder;
//   final int totalJokes;
//   final bool hasMore;
//   final bool isLoading;

//   InjectedSlotRenderData get _renderData => InjectedSlotRenderData(
//     slotIndex: slotIndex,
//     realJokesBefore: realJokesBefore,
//     totalJokes: totalJokes,
//     hasMore: hasMore,
//     isLoading: isLoading,
//   );

//   Widget build(BuildContext context) => builder(context, _renderData);
// }

// /// Descriptor returned by injection strategies.
// class InjectedSlotDescriptor {
//   const InjectedSlotDescriptor({
//     required this.id,
//     required this.jokesBefore,
//     required this.builder,
//     this.priority = 0,
//   }) : assert(jokesBefore >= 0, 'jokesBefore cannot be negative');

//   final String id;
//   final int jokesBefore;
//   final InjectedSlotBuilder builder;
//   final int priority;

//   InjectedSlotDescriptor copyWith({int? jokesBefore}) {
//     return InjectedSlotDescriptor(
//       id: id,
//       jokesBefore: jokesBefore ?? this.jokesBefore,
//       builder: builder,
//       priority: priority,
//     );
//   }
// }

// /// Contract for strategies that programmatically inject slots into the list.
// abstract class JokeListInjectionStrategy {
//   const JokeListInjectionStrategy();

//   Iterable<InjectedSlotDescriptor> build({
//     required List<JokeWithDate> jokes,
//     required bool hasMore,
//     required bool isLoading,
//   });
// }

// /// Strategy that inserts a card after every N jokes.
// class PeriodicInjectedCardStrategy extends JokeListInjectionStrategy {
//   const PeriodicInjectedCardStrategy({
//     required this.every,
//     required this.builder,
//     required this.idPrefix,
//     this.startAfter = 0,
//     this.maxInsertions,
//     this.priority = 0,
//   }) : assert(every > 0, 'every must be greater than zero');

//   final int every;
//   final InjectedSlotBuilder builder;
//   final String idPrefix;
//   final int startAfter;
//   final int? maxInsertions;
//   final int priority;

//   @override
//   Iterable<InjectedSlotDescriptor> build({
//     required List<JokeWithDate> jokes,
//     required bool hasMore,
//     required bool isLoading,
//   }) sync* {
//     if (jokes.isEmpty) return;
//     final int startIndex = startAfter.clamp(0, jokes.length);
//     int insertionCount = 0;
//     int jokesBefore = startIndex + every;
//     while (jokesBefore <= jokes.length) {
//       if (maxInsertions != null && insertionCount >= maxInsertions!) {
//         break;
//       }
//       yield InjectedSlotDescriptor(
//         id: '$idPrefix-$jokesBefore-$insertionCount',
//         jokesBefore: jokesBefore,
//         builder: builder,
//         priority: priority,
//       );
//       insertionCount++;
//       jokesBefore += every;
//     }
//   }
// }

// /// Strategy that inserts a card after the final joke once the data source is
// /// exhausted (or immediately if configured).
// class TerminalInjectedCardStrategy extends JokeListInjectionStrategy {
//   const TerminalInjectedCardStrategy({
//     required this.id,
//     required this.builder,
//     this.onlyWhenHasMoreIsFalse = true,
//     this.onlyWhenNotLoading = false,
//     this.priority = 0,
//   });

//   final String id;
//   final InjectedSlotBuilder builder;
//   final bool onlyWhenHasMoreIsFalse;
//   final bool onlyWhenNotLoading;
//   final int priority;

//   @override
//   Iterable<InjectedSlotDescriptor> build({
//     required List<JokeWithDate> jokes,
//     required bool hasMore,
//     required bool isLoading,
//   }) {
//     if (onlyWhenHasMoreIsFalse && hasMore) {
//       return const <InjectedSlotDescriptor>[];
//     }
//     if (onlyWhenNotLoading && isLoading) {
//       return const <InjectedSlotDescriptor>[];
//     }
//     return <InjectedSlotDescriptor>[
//       InjectedSlotDescriptor(
//         id: id,
//         jokesBefore: jokes.length,
//         builder: builder,
//         priority: priority,
//       ),
//     ];
//   }
// }

// /// Injection strategy that adds an end-of-feed message when the viewer is
// /// exhausted.
// class EndOfFeedInjectedCardStrategy extends JokeListInjectionStrategy {
//   const EndOfFeedInjectedCardStrategy({required this.jokeContext});

//   static const String slotId = 'end_of_feed';
//   final String jokeContext;

//   @override
//   Iterable<InjectedSlotDescriptor> build({
//     required List<JokeWithDate> jokes,
//     required bool hasMore,
//     required bool isLoading,
//   }) {
//     final shouldInject = !hasMore && !isLoading;
//     if (!shouldInject) return const Iterable<InjectedSlotDescriptor>.empty();
//     return <InjectedSlotDescriptor>[
//       InjectedSlotDescriptor(
//         id: slotId,
//         jokesBefore: jokes.length,
//         builder: (context, data) =>
//             _EndOfFeedCard(jokeContext: jokeContext, slotData: data),
//         priority: 1,
//       ),
//     ];
//   }
// }

// class _PendingInjectedSlot {
//   _PendingInjectedSlot({required this.descriptor, required this.order});

//   final InjectedSlotDescriptor descriptor;
//   final int order;
// }

// class _SequenceBuildResult {
//   const _SequenceBuildResult({
//     required this.slots,
//     required this.realJokesBefore,
//     required this.jokeIndexToSlotIndex,
//   });

//   final List<JokeListSlot> slots;
//   final List<int> realJokesBefore;
//   final List<int> jokeIndexToSlotIndex;
// }

// /// Immutable sequence of slots derived from a list of jokes plus optional
// /// injection strategies.
// class JokeListSlotSequence {
//   JokeListSlotSequence({
//     required List<JokeWithDate> jokes,
//     List<JokeListInjectionStrategy> strategies = const [],
//     bool hasMore = false,
//     bool isLoading = false,
//   }) : _jokes = List<JokeWithDate>.unmodifiable(jokes) {
//     final result = _buildSlots(
//       jokes: _jokes,
//       strategies: strategies,
//       hasMore: hasMore,
//       isLoading: isLoading,
//     );
//     _slots = List<JokeListSlot>.unmodifiable(result.slots);
//     _realJokesBefore = List<int>.unmodifiable(result.realJokesBefore);
//     _jokeIndexToSlotIndex = List<int>.unmodifiable(result.jokeIndexToSlotIndex);
//   }

//   final List<JokeWithDate> _jokes;
//   late final List<JokeListSlot> _slots;
//   late final List<int> _realJokesBefore;
//   late final List<int> _jokeIndexToSlotIndex;

//   static _SequenceBuildResult _buildSlots({
//     required List<JokeWithDate> jokes,
//     required List<JokeListInjectionStrategy> strategies,
//     required bool hasMore,
//     required bool isLoading,
//   }) {
//     final pending = <_PendingInjectedSlot>[];
//     int order = 0;
//     for (final strategy in strategies) {
//       final descriptors = strategy.build(
//         jokes: jokes,
//         hasMore: hasMore,
//         isLoading: isLoading,
//       );
//       for (final descriptor in descriptors) {
//         final clampedBefore = descriptor.jokesBefore.clamp(0, jokes.length);
//         pending.add(
//           _PendingInjectedSlot(
//             descriptor: descriptor.copyWith(jokesBefore: clampedBefore),
//             order: order++,
//           ),
//         );
//       }
//     }

//     pending.sort((a, b) {
//       final byPosition = a.descriptor.jokesBefore.compareTo(
//         b.descriptor.jokesBefore,
//       );
//       if (byPosition != 0) return byPosition;
//       final byPriority = b.descriptor.priority.compareTo(a.descriptor.priority);
//       if (byPriority != 0) return byPriority;
//       return a.order.compareTo(b.order);
//     });

//     final slots = <JokeListSlot>[];
//     final realJokesBefore = <int>[];
//     final jokeIndexToSlotIndex = List<int>.filled(
//       jokes.length,
//       -1,
//       growable: false,
//     );

//     int slotIndex = 0;
//     int pendingIndex = 0;
//     for (var jokeIndex = 0; jokeIndex < jokes.length; jokeIndex++) {
//       while (pendingIndex < pending.length &&
//           pending[pendingIndex].descriptor.jokesBefore == jokeIndex) {
//         final descriptor = pending[pendingIndex].descriptor;
//         slots.add(
//           InjectedSlot(
//             slotIndex: slotIndex,
//             id: descriptor.id,
//             realJokesBefore: jokeIndex,
//             builder: descriptor.builder,
//             totalJokes: jokes.length,
//             hasMore: hasMore,
//             isLoading: isLoading,
//           ),
//         );
//         realJokesBefore.add(jokeIndex);
//         slotIndex++;
//         pendingIndex++;
//       }

//       slots.add(
//         JokeSlot(
//           slotIndex: slotIndex,
//           jokeIndex: jokeIndex,
//           joke: jokes[jokeIndex],
//         ),
//       );
//       realJokesBefore.add(jokeIndex);
//       jokeIndexToSlotIndex[jokeIndex] = slotIndex;
//       slotIndex++;
//     }

//     while (pendingIndex < pending.length) {
//       final descriptor = pending[pendingIndex].descriptor;
//       slots.add(
//         InjectedSlot(
//           slotIndex: slotIndex,
//           id: descriptor.id,
//           realJokesBefore: jokes.length,
//           builder: descriptor.builder,
//           totalJokes: jokes.length,
//           hasMore: hasMore,
//           isLoading: isLoading,
//         ),
//       );
//       realJokesBefore.add(jokes.length);
//       slotIndex++;
//       pendingIndex++;
//     }

//     return _SequenceBuildResult(
//       slots: slots,
//       realJokesBefore: realJokesBefore,
//       jokeIndexToSlotIndex: jokeIndexToSlotIndex,
//     );
//   }

//   List<JokeWithDate> get jokes => _jokes;
//   int get slotCount => _slots.length;
//   int get totalJokes => _jokes.length;
//   bool get hasJokes => totalJokes > 0;

//   JokeListSlot slotAt(int slotIndex) => _slots[slotIndex];

//   JokeSlot jokeSlotAt(int slotIndex) => _slots[slotIndex] as JokeSlot;

//   int? jokeIndexForSlot(int slotIndex) {
//     if (slotIndex < 0 || slotIndex >= _slots.length) {
//       return null;
//     }
//     final slot = _slots[slotIndex];
//     if (slot is JokeSlot) return slot.jokeIndex;
//     return null;
//   }

//   int? slotIndexForJokeIndex(int jokeIndex) {
//     if (jokeIndex < 0 || jokeIndex >= _jokeIndexToSlotIndex.length) {
//       return null;
//     }
//     final slotIndex = _jokeIndexToSlotIndex[jokeIndex];
//     return slotIndex >= 0 ? slotIndex : null;
//   }

//   int realJokesBefore(int slotIndex) {
//     if (slotIndex < 0 || slotIndex >= _realJokesBefore.length) {
//       return 0;
//     }
//     return _realJokesBefore[slotIndex];
//   }

//   int? firstJokeSlotAfter(int slotIndex) {
//     for (int i = slotIndex + 1; i < _slots.length; i++) {
//       if (_slots[i] is JokeSlot) return i;
//     }
//     return null;
//   }

//   int? lastJokeSlotAtOrBefore(int slotIndex) {
//     if (_slots.isEmpty) return null;
//     int start = slotIndex;
//     if (start >= _slots.length) {
//       start = _slots.length - 1;
//     }
//     if (start < 0) return null;
//     for (int i = start; i >= 0; i--) {
//       if (_slots[i] is JokeSlot) return i;
//     }
//     return null;
//   }
// }

// class _EndOfFeedCard extends ConsumerStatefulWidget {
//   const _EndOfFeedCard({required this.jokeContext, required this.slotData});

//   final String jokeContext;
//   final InjectedSlotRenderData slotData;

//   @override
//   ConsumerState<_EndOfFeedCard> createState() => _EndOfFeedCardState();
// }

// class _EndOfFeedCardState extends ConsumerState<_EndOfFeedCard> {
//   bool _logged = false;

//   @override
//   void didChangeDependencies() {
//     super.didChangeDependencies();
//     if (_logged) return;
//     WidgetsBinding.instance.addPostFrameCallback((_) {
//       if (!mounted || _logged) return;
//       unawaited(_logCompositeScrollState());
//       final analytics = ref.read(analyticsServiceProvider);
//       analytics.logJokeFeedEndViewed(jokeContext: widget.jokeContext);
//       _logged = true;
//     });
//   }

//   Future<void> _logCompositeScrollState() async {
//     final data = widget.slotData;
//     final appUsage = ref.read(appUsageServiceProvider);
//     final jokesViewed = await appUsage.getNumJokesViewed();
//     final jokesNavigated = await appUsage.getNumJokesNavigated();
//     AppLogger.error(
//       'PAGING_INTERNAL: COMPOSITE: End-of-feed card viewed ('
//       'jokeContext=${widget.jokeContext}, '
//       'slotIndex=${data.slotIndex}, '
//       'totalJokes=${data.totalJokes}, '
//       'hasMore=${data.hasMore}, '
//       'isLoading=${data.isLoading}, '
//       'usage.jokesViewed=$jokesViewed, '
//       'usage.jokesNavigated=$jokesNavigated)',
//     );
//   }

//   @override
//   Widget build(BuildContext context) {
//     final theme = Theme.of(context);
//     final background = theme.colorScheme.surfaceContainerHighest;
//     final textColor = theme.textTheme.bodyMedium?.color;
//     final subtleTextColor = textColor?.withAlpha((0.8 * 255).round());
//     return Card(
//       elevation: 0,
//       color: background,
//       shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
//       child: Padding(
//         padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 24),
//         child: Column(
//           mainAxisSize: MainAxisSize.min,
//           children: [
//             Icon(
//               Icons.emoji_emotions_outlined,
//               color: theme.colorScheme.primary,
//               size: 28,
//             ),
//             const SizedBox(height: 12),
//             Text(
//               "You're all caught up!",
//               style: theme.textTheme.titleMedium?.copyWith(
//                 fontWeight: FontWeight.w600,
//               ),
//               textAlign: TextAlign.center,
//             ),
//             const SizedBox(height: 8),
//             Text(
//               'Fresh jokes drop tomorrow. Come back for more laughs!',
//               style: theme.textTheme.bodyMedium?.copyWith(
//                 color: subtleTextColor,
//               ),
//               textAlign: TextAlign.center,
//             ),
//           ],
//         ),
//       ),
//     );
//   }
// }
