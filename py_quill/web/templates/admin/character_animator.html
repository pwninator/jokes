{% extends "admin/admin_base.html" %}

{% block title %}Character Animator Â· {{ site_name }} Admin{% endblock %}

{% block content %}
<style>
  .animator-controls {
    display: flex;
    gap: 16px;
    margin-bottom: 24px;
    align-items: center;
    flex-wrap: wrap;
    background: #f8f9fa;
    padding: 16px;
    border-radius: 8px;
    border: 1px solid #dee2e6;
  }
  .stage-container {
    background: #f0f0f0;
    border: 1px solid #ccc;
    position: relative;
    overflow: hidden;
    margin: 0 auto;
  }
  .control-group {
    display: flex;
    gap: 8px;
    align-items: center;
    border-right: 1px solid #ddd;
    padding-right: 16px;
  }
  .control-group:last-child {
    border-right: none;
  }
</style>

<h2>Character Animator</h2>

<div class="animator-controls">
  <div class="control-group">
    <select id="def-select" style="padding: 8px;">
      <option value="">Select Character Definition</option>
      {% for def in character_defs %}
        <option value="{{ def.key }}">{{ def.name or def.key }}</option>
      {% endfor %}
    </select>
    <button id="edit-char-btn" class="text-button">Edit Character</button>
  </div>

  <div class="control-group">
    <select id="seq-select" style="padding: 8px;">
      <option value="">Select Sequence</option>
      {% for seq in sequences %}
        <option value="{{ seq.key }}">{{ seq.key }}</option>
      {% endfor %}
    </select>
    <button id="load-btn" class="text-button">Load</button>
  </div>

  <div class="control-group">
    <button id="new-seq-btn" class="text-button">New Sequence</button>
  </div>

  <div class="control-group">
    <input type="text" id="seq-id-input" placeholder="Sequence ID" style="padding: 8px;" disabled>
    <button id="save-btn" class="text-button primary">Save Sequence</button>
  </div>

  <div class="control-group">
    <button id="play-btn" class="text-button" disabled>Play</button>
    <button id="pause-btn" class="text-button" disabled>Pause</button>
  </div>
</div>

<div id="character-editor-container" style="display: none; background: #fff; border: 1px solid #ccc; padding: 16px; margin-bottom: 24px;">
    <h3>Character Editor</h3>
    <input type="hidden" id="char-id-input">
    <div style="display: flex; flex-direction: column; gap: 8px;">
        <label>Name: <input type="text" id="char-name" style="width: 100%;"></label>
        <div style="display: flex; gap: 16px;">
            <label>Width: <span id="char-width-text"></span></label>
            <label>Height: <span id="char-height-text"></span></label>
        </div>
        <label>Head GCS URI: <input type="text" id="char-head-uri" style="width: 100%;"></label>
        <label>Left Hand GCS URI: <input type="text" id="char-left-hand-uri" style="width: 100%;"></label>
        <label>Right Hand GCS URI: <input type="text" id="char-right-hand-uri" style="width: 100%;"></label>
        <label>Mouth Open GCS URI: <input type="text" id="char-mouth-open-uri" style="width: 100%;"></label>
        <label>Mouth Closed GCS URI: <input type="text" id="char-mouth-closed-uri" style="width: 100%;"></label>
        <label>Mouth O GCS URI: <input type="text" id="char-mouth-o-uri" style="width: 100%;"></label>
        <label>Left Eye Open GCS URI: <input type="text" id="char-left-eye-open-uri" style="width: 100%;"></label>
        <label>Left Eye Closed GCS URI: <input type="text" id="char-left-eye-closed-uri" style="width: 100%;"></label>
        <label>Right Eye Open GCS URI: <input type="text" id="char-right-eye-open-uri" style="width: 100%;"></label>
        <label>Right Eye Closed GCS URI: <input type="text" id="char-right-eye-closed-uri" style="width: 100%;"></label>
        <div style="display: flex; gap: 8px; align-items: center;">
            <label>File Identifier: <input type="text" id="char-file-identifier"></label>
            <button id="fill-uris-btn" class="text-button">Fill URIs</button>
        </div>

        <div style="margin-top: 16px; display: flex; gap: 16px;">
            <button id="new-char-btn" class="text-button">New Character (Clear)</button>
            <button id="save-char-btn" class="text-button primary">Save Character</button>
        </div>
    </div>
</div>

<div id="stage" class="stage-container">
    <!-- Structure for animator -->
    <div id="head-group" style="position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;">
        <img id="char-head-base" style="grid-area: 1/1; max-width: none;">
        <img id="char-eye-l" style="grid-area: 1/1; max-width: none;">
        <img id="char-eye-r" style="grid-area: 1/1; max-width: none;">
        <img id="char-mouth" style="grid-area: 1/1; max-width: none;">
    </div>
    <div id="hand-l-group" style="position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;">
        <img id="char-hand-l" style="grid-area: 1/1; max-width: none;">
    </div>
    <div id="hand-r-group" style="position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;">
        <img id="char-hand-r" style="grid-area: 1/1; max-width: none;">
    </div>
</div>

<div id="editor-container"></div>

<script type="module">
  import { CharacterAnimator } from "{{ url_for('static', filename='js/character_animator.js') }}";
  import { CharacterEditor } from "{{ url_for('static', filename='js/character_editor.js') }}";

  let animator = null;
  let editor = null;
  let isSequenceDirty = false;

  // DOM Elements
  const stage = document.getElementById('stage');
  const headGroup = document.getElementById('head-group');
  const handLGroup = document.getElementById('hand-l-group');
  const handRGroup = document.getElementById('hand-r-group');

  const imgHead = document.getElementById('char-head-base');
  const imgEyeL = document.getElementById('char-eye-l');
  const imgEyeR = document.getElementById('char-eye-r');
  const imgMouth = document.getElementById('char-mouth');
  const imgHandL = document.getElementById('char-hand-l');
  const imgHandR = document.getElementById('char-hand-r');

  const loadBtn = document.getElementById('load-btn');
  const newSeqBtn = document.getElementById('new-seq-btn');
  const saveBtn = document.getElementById('save-btn');
  const playBtn = document.getElementById('play-btn');
  const pauseBtn = document.getElementById('pause-btn');
  const seqSelect = document.getElementById('seq-select');
  const seqIdInput = document.getElementById('seq-id-input');
  const defSelect = document.getElementById('def-select');

  // Character Editor Elements
  const charEditorContainer = document.getElementById('character-editor-container');
  const charIdInput = document.getElementById('char-id-input');
  const charNameInput = document.getElementById('char-name');
  const charWidthText = document.getElementById('char-width-text');
  const charHeightText = document.getElementById('char-height-text');
  const charHeadUriInput = document.getElementById('char-head-uri');
  const charLeftHandUriInput = document.getElementById('char-left-hand-uri');
  const charRightHandUriInput = document.getElementById('char-right-hand-uri');
  const charMouthOpenUriInput = document.getElementById('char-mouth-open-uri');
  const charMouthClosedUriInput = document.getElementById('char-mouth-closed-uri');
  const charMouthOUriInput = document.getElementById('char-mouth-o-uri');
  const charLeftEyeOpenUriInput = document.getElementById('char-left-eye-open-uri');
  const charLeftEyeClosedUriInput = document.getElementById('char-left-eye-closed-uri');
  const charRightEyeOpenUriInput = document.getElementById('char-right-eye-open-uri');
  const charRightEyeClosedUriInput = document.getElementById('char-right-eye-closed-uri');
  const charFileIdentifierInput = document.getElementById('char-file-identifier');

  function createEmptySequence() {
      return {
          sequence_head_transform: [],
          sequence_left_hand_transform: [],
          sequence_right_hand_transform: [],
          sequence_left_eye_open: [],
          sequence_right_eye_open: [],
          sequence_mouth_state: [],
          sequence_left_hand_visible: [],
          sequence_right_hand_visible: [],
          sequence_sound_events: []
      };
  }

  function normalizeSequenceData(sequence) {
      const normalized = createEmptySequence();
      const source = sequence || {};
      Object.keys(normalized).forEach((trackName) => {
          normalized[trackName] = Array.isArray(source[trackName]) ? source[trackName] : [];
      });
      return normalized;
  }

  function setSequenceDirty(isDirty) {
      isSequenceDirty = isDirty;
  }

  function confirmDiscardSequenceChanges() {
      if (!isSequenceDirty) {
          return true;
      }
      return confirm('Start over and discard unsaved sequence changes?');
  }

  function setPlaybackButtonsEnabled(isEnabled) {
      playBtn.disabled = !isEnabled;
      pauseBtn.disabled = !isEnabled;
  }

  function setSequenceIdState(sequenceId, isExisting) {
      seqIdInput.value = sequenceId || '';
      seqIdInput.disabled = isExisting;
  }

  function ensureSequenceOption(sequenceId) {
      if (!sequenceId) {
          return;
      }
      const exists = Array.from(seqSelect.options).some((option) => option.value === sequenceId);
      if (exists) {
          return;
      }
      const option = document.createElement('option');
      option.value = sequenceId;
      option.textContent = sequenceId;
      seqSelect.appendChild(option);
  }

  function getDomElements() {
      return {
        head: headGroup,
        mouth: imgMouth,
        leftEye: imgEyeL,
        rightEye: imgEyeR,
        leftHand: handLGroup,
        rightHand: handRGroup
      };
  }

  async function fetchAnimatorData(payload) {
      const resp = await fetch('/admin/api/character-animator/data', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
      });
      if (resp.ok) {
          return resp.json();
      }

      let message = 'Request failed';
      try {
          const errorData = await resp.json();
          message = errorData.error || message;
      } catch (_err) {
          message = await resp.text();
      }
      throw new Error(message);
  }

  async function fetchDefinition(defId) {
      const data = await fetchAnimatorData({ def_id: defId });
      if (!data.definition) {
          throw new Error('Character definition not found');
      }
      return data.definition;
  }

  document.getElementById('edit-char-btn').addEventListener('click', () => {
      const isHidden = charEditorContainer.style.display === 'none';
      charEditorContainer.style.display = isHidden ? 'block' : 'none';
      if (isHidden) {
          loadCharacterDefinitionIntoForm();
      }
  });

  defSelect.addEventListener('change', () => {
      if (charEditorContainer.style.display !== 'none') {
          loadCharacterDefinitionIntoForm();
      }
  });

  async function loadCharacterDefinitionIntoForm() {
      const defId = defSelect.value;
      if (!defId) {
          clearCharacterForm();
          return;
      }

      try {
          const def = await fetchDefinition(defId);
          populateCharacterForm(def);
      } catch (e) {
          console.error(e);
          alert('Error loading character: ' + e.message);
      }
  }

  function populateCharacterForm(def) {
      charIdInput.value = def.key || '';
      charNameInput.value = def.name || '';
      charWidthText.textContent = def.width ?? '';
      charHeightText.textContent = def.height ?? '';
      charHeadUriInput.value = def.head_gcs_uri || '';
      charLeftHandUriInput.value = def.left_hand_gcs_uri || '';
      charRightHandUriInput.value = def.right_hand_gcs_uri || '';
      charMouthOpenUriInput.value = def.mouth_open_gcs_uri || '';
      charMouthClosedUriInput.value = def.mouth_closed_gcs_uri || '';
      charMouthOUriInput.value = def.mouth_o_gcs_uri || '';
      charLeftEyeOpenUriInput.value = def.left_eye_open_gcs_uri || '';
      charLeftEyeClosedUriInput.value = def.left_eye_closed_gcs_uri || '';
      charRightEyeOpenUriInput.value = def.right_eye_open_gcs_uri || '';
      charRightEyeClosedUriInput.value = def.right_eye_closed_gcs_uri || '';
  }

  function clearCharacterForm() {
      charIdInput.value = '';
      charNameInput.value = '';
      charWidthText.textContent = '';
      charHeightText.textContent = '';
      charHeadUriInput.value = '';
      charLeftHandUriInput.value = '';
      charRightHandUriInput.value = '';
      charMouthOpenUriInput.value = '';
      charMouthClosedUriInput.value = '';
      charMouthOUriInput.value = '';
      charLeftEyeOpenUriInput.value = '';
      charLeftEyeClosedUriInput.value = '';
      charRightEyeOpenUriInput.value = '';
      charRightEyeClosedUriInput.value = '';
      charFileIdentifierInput.value = '';
  }

  document.getElementById('fill-uris-btn').addEventListener('click', (e) => {
      e.preventDefault();
      const fileIdentifier = charFileIdentifierInput.value.trim();
      if (!fileIdentifier) {
          alert('Please enter a file identifier.');
          return;
      }

      const baseUri = `gs://images.quillsstorybook.com/_joke_assets/characters/${fileIdentifier}`;
      charHeadUriInput.value = `${baseUri}/${fileIdentifier}_head.png`;
      charLeftHandUriInput.value = `${baseUri}/${fileIdentifier}_hand_left.png`;
      charRightHandUriInput.value = `${baseUri}/${fileIdentifier}_hand_right.png`;
      charMouthOpenUriInput.value = `${baseUri}/${fileIdentifier}_mouth_open.png`;
      charMouthClosedUriInput.value = `${baseUri}/${fileIdentifier}_mouth_closed.png`;
      charMouthOUriInput.value = `${baseUri}/${fileIdentifier}_mouth_o.png`;
      charLeftEyeOpenUriInput.value = `${baseUri}/${fileIdentifier}_eye_left_open.png`;
      charLeftEyeClosedUriInput.value = `${baseUri}/${fileIdentifier}_eye_left_closed.png`;
      charRightEyeOpenUriInput.value = `${baseUri}/${fileIdentifier}_eye_right_open.png`;
      charRightEyeClosedUriInput.value = `${baseUri}/${fileIdentifier}_eye_right_closed.png`;
  });

  document.getElementById('new-char-btn').addEventListener('click', (e) => {
      e.preventDefault();
      clearCharacterForm();
      defSelect.value = ""; // clear selection
  });

  document.getElementById('save-char-btn').addEventListener('click', async (e) => {
      e.preventDefault();
      const btn = e.target;
      btn.disabled = true;
      btn.textContent = 'Saving...';

      try {
          const formData = new FormData();
          formData.append('op', 'character');
          if (charIdInput.value) formData.append('character_id', charIdInput.value);
          formData.append('name', charNameInput.value);
          formData.append('head_gcs_uri', charHeadUriInput.value);
          formData.append('left_hand_gcs_uri', charLeftHandUriInput.value);
          formData.append('right_hand_gcs_uri', charRightHandUriInput.value);
          formData.append('mouth_open_gcs_uri', charMouthOpenUriInput.value);
          formData.append('mouth_closed_gcs_uri', charMouthClosedUriInput.value);
          formData.append('mouth_o_gcs_uri', charMouthOUriInput.value);
          formData.append('left_eye_open_gcs_uri', charLeftEyeOpenUriInput.value);
          formData.append('left_eye_closed_gcs_uri', charLeftEyeClosedUriInput.value);
          formData.append('right_eye_open_gcs_uri', charRightEyeOpenUriInput.value);
          formData.append('right_eye_closed_gcs_uri', charRightEyeClosedUriInput.value);

          const resp = await fetch('/joke_creation_process', {
              method: 'POST',
              body: formData
          });

          if (!resp.ok) {
              const text = await resp.text();
              throw new Error(text);
          }

          alert('Character saved successfully!');
          if (confirm("Reload page to update list?")) {
              window.location.reload();
          }

      } catch (err) {
          console.error(err);
          alert('Error saving character: ' + err.message);
      } finally {
          btn.disabled = false;
          btn.textContent = 'Save Character';
      }
  });

  async function startSequenceEditor(definition, sequenceData, sequenceId, isExisting) {
      const normalizedSequence = normalizeSequenceData(sequenceData);
      setupStage(definition);
      initializeComponents(normalizedSequence, definition);
      setSequenceIdState(sequenceId, isExisting);
      if (!isExisting) {
          seqSelect.value = '';
      }
      setSequenceDirty(false);
  }

  async function loadExistingSequence() {
    const defId = defSelect.value;
    const seqId = seqSelect.value;

    if (!defId || !seqId) {
      alert('Please select both a definition and a sequence.');
      return;
    }
    if (!confirmDiscardSequenceChanges()) {
      return;
    }

    loadBtn.disabled = true;
    loadBtn.textContent = 'Loading...';

    try {
      const data = await fetchAnimatorData({ def_id: defId, seq_id: seqId });
      const def = data.definition;
      const seq = data.sequence;
      if (!def || !seq) {
          throw new Error('Missing definition or sequence payload');
      }

      await startSequenceEditor(def, seq, seq.key || seqId, true);

    } catch (e) {
      console.error(e);
      alert('Error loading animation: ' + e.message);
    } finally {
      loadBtn.disabled = false;
      loadBtn.textContent = 'Load';
    }
  }

  async function createNewSequence() {
      const defId = defSelect.value;
      if (!defId) {
          alert('Please select a Character Definition first.');
          return;
      }
      if (!confirmDiscardSequenceChanges()) {
          return;
      }

      newSeqBtn.disabled = true;
      newSeqBtn.textContent = 'Preparing...';

      try {
          const definition = await fetchDefinition(defId);
          await startSequenceEditor(definition, createEmptySequence(), '', false);
      } catch (e) {
          console.error(e);
          alert('Error creating new sequence: ' + e.message);
      } finally {
          newSeqBtn.disabled = false;
          newSeqBtn.textContent = 'New Sequence';
      }
  }

  async function saveSequence() {
      if (!editor) {
          alert('Load or create a sequence first.');
          return;
      }

      const seqId = seqIdInput.value.trim();
      const sequenceData = normalizeSequenceData(editor.sequenceData);

      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';

      try {
          const formData = new FormData();
          formData.append('op', 'animation');
          formData.append('sequence_data', JSON.stringify(sequenceData));
          if (seqId) {
              formData.append('sequence_id', seqId);
          }

          const resp = await fetch('/joke_creation_process', {
              method: 'POST',
              body: formData
          });

          if (!resp.ok) {
              const text = await resp.text();
              throw new Error(text);
          }

          const result = await resp.json();
          const savedSeq = result.data;

          alert('Sequence saved successfully!');
          if (savedSeq.key) {
              setSequenceIdState(savedSeq.key, true);
              ensureSequenceOption(savedSeq.key);
              seqSelect.value = savedSeq.key;
              setSequenceDirty(false);
          }

          if (confirm("Reload page to update list?")) {
              window.location.reload();
          }

      } catch (e) {
          console.error(e);
          alert('Error saving: ' + e.message);
      } finally {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Sequence';
      }
  }

  loadBtn.addEventListener('click', loadExistingSequence);
  newSeqBtn.addEventListener('click', createNewSequence);
  saveBtn.addEventListener('click', saveSequence);
  playBtn.addEventListener('click', () => animator?.play());
  pauseBtn.addEventListener('click', () => animator?.pause());

  function setupStage(def) {
      stage.style.width = `${def.width}px`;
      stage.style.height = `${def.height}px`;

      imgHead.src = def.head_gcs_uri;
      imgHandL.src = def.left_hand_gcs_uri;
      imgHandR.src = def.right_hand_gcs_uri;

      imgEyeL.src = def.left_eye_open_gcs_uri || '';
      imgEyeR.src = def.right_eye_open_gcs_uri || '';
      imgMouth.src = def.mouth_closed_gcs_uri || '';
  }

  function initializeComponents(seq, def) {
      if (animator) {
          animator.pause();
      }
      if (editor) {
          editor.destroy();
      }

      setPlaybackButtonsEnabled(false);
      animator = new CharacterAnimator(seq, getDomElements(), def);
      animator.init().then(() => {
          setPlaybackButtonsEnabled(true);
      }).catch((err) => {
          console.error(err);
          alert('Error initializing animator: ' + err.message);
      });

      const container = document.getElementById('editor-container');
      editor = new CharacterEditor(container, seq, (updatedSeq) => {
          setSequenceDirty(true);
          if (animator) {
              animator.updateSequence(updatedSeq);
              animator.seek(0);
          }
      });
  }

  setPlaybackButtonsEnabled(false);
</script>
{% endblock %}
