{% extends "admin/admin_base.html" %}

{% block title %}Character Animator Â· {{ site_name }} Admin{% endblock %}

{% block content %}
<style>
  .animator-controls {
    display: flex;
    gap: 16px;
    margin-bottom: 24px;
    align-items: center;
    flex-wrap: wrap;
    background: #f8f9fa;
    padding: 16px;
    border-radius: 8px;
    border: 1px solid #dee2e6;
  }
  .stage-container {
    background: #f0f0f0;
    border: 1px solid #ccc;
    position: relative;
    overflow: hidden;
    margin: 0 auto;
  }
  .control-group {
    display: flex;
    gap: 8px;
    align-items: center;
    border-right: 1px solid #ddd;
    padding-right: 16px;
  }
  .control-group:last-child {
    border-right: none;
  }
</style>

<h2>Character Animator</h2>

<div class="animator-controls">
  <div class="control-group">
    <select id="def-select" style="padding: 8px;">
      <option value="">Select Character Definition</option>
      {% for def in character_defs %}
        <option value="{{ def.key }}">{{ def.name or def.key }}</option>
      {% endfor %}
    </select>
    <button id="edit-char-btn" class="text-button">Edit Character</button>
  </div>

  <div class="control-group">
    <select id="seq-select" style="padding: 8px;">
      <option value="">Select Sequence</option>
      {% for seq in sequences %}
        <option value="{{ seq.key }}">{{ seq.key }}</option>
      {% endfor %}
    </select>
    <button id="load-btn" class="text-button">Load</button>
  </div>

  <div class="control-group">
    <button id="new-seq-btn" class="text-button">New Sequence</button>
  </div>

  <div class="control-group">
    <input type="text" id="laugh-audio-uri-input" placeholder="Laugh Audio GCS URI" style="padding: 8px; min-width: 280px;">
    <button id="laugh-btn" class="text-button">Laugh</button>
  </div>

  <div class="control-group">
    <input type="text" id="seq-id-input" placeholder="Sequence ID" style="padding: 8px;" disabled>
    <button id="save-btn" class="text-button primary">Save Sequence</button>
  </div>

  <div class="control-group">
    <button id="play-btn" class="text-button" disabled>Play</button>
    <button id="pause-btn" class="text-button" disabled>Pause</button>
  </div>
</div>

<div id="character-editor-container" style="display: none; background: #fff; border: 1px solid #ccc; padding: 16px; margin-bottom: 24px;">
    <h3>Character Editor</h3>
    <input type="hidden" id="char-id-input">
    <div id="char-create-id-row" style="margin-bottom: 8px;">
        <label>Firestore Doc ID: <input type="text" id="char-create-id-input" style="width: 100%;" required></label>
    </div>
    <div id="char-existing-id-row" style="display: none; margin-bottom: 8px;">
        <strong>Firestore Doc ID:</strong> <span id="char-existing-id-text"></span>
    </div>
    <div style="display: flex; flex-direction: column; gap: 8px;">
        <label>Name: <input type="text" id="char-name" style="width: 100%;"></label>
        <div style="display: flex; gap: 16px;">
            <label>Width: <span id="char-width-text"></span></label>
            <label>Height: <span id="char-height-text"></span></label>
        </div>
        <label>Head GCS URI: <input type="text" id="char-head-uri" style="width: 100%;"></label>
        <label>Left Hand GCS URI: <input type="text" id="char-left-hand-uri" style="width: 100%;"></label>
        <label>Right Hand GCS URI: <input type="text" id="char-right-hand-uri" style="width: 100%;"></label>
        <label>Mouth Open GCS URI: <input type="text" id="char-mouth-open-uri" style="width: 100%;"></label>
        <label>Mouth Closed GCS URI: <input type="text" id="char-mouth-closed-uri" style="width: 100%;"></label>
        <label>Mouth O GCS URI: <input type="text" id="char-mouth-o-uri" style="width: 100%;"></label>
        <label>Left Eye Open GCS URI: <input type="text" id="char-left-eye-open-uri" style="width: 100%;"></label>
        <label>Left Eye Closed GCS URI: <input type="text" id="char-left-eye-closed-uri" style="width: 100%;"></label>
        <label>Right Eye Open GCS URI: <input type="text" id="char-right-eye-open-uri" style="width: 100%;"></label>
        <label>Right Eye Closed GCS URI: <input type="text" id="char-right-eye-closed-uri" style="width: 100%;"></label>
        <label>Surface Line GCS URI: <input type="text" id="char-surface-line-uri" style="width: 100%;"></label>
        <div style="display: flex; gap: 8px; align-items: center;">
            <label>File Identifier: <input type="text" id="char-file-identifier"></label>
            <button id="fill-uris-btn" class="text-button">Fill URIs</button>
        </div>

        <div style="margin-top: 16px; display: flex; gap: 16px;">
            <button id="new-char-btn" class="text-button">New Character (Clear)</button>
            <button id="save-char-btn" class="text-button primary">Save Character</button>
        </div>
    </div>
</div>

<div id="stage" class="stage-container">
    <!-- Structure for animator -->
    <div id="head-group" style="position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;">
        <div id="head-transform" style="position: absolute; inset: 0; display: grid; place-items: center; transform-origin: center center;">
            <img id="char-head-base" style="grid-area: 1/1; max-width: none;">
            <img id="char-eye-l" style="grid-area: 1/1; max-width: none;">
            <img id="char-eye-r" style="grid-area: 1/1; max-width: none;">
            <img id="char-mouth" style="grid-area: 1/1; max-width: none;">
        </div>
    </div>
    <div id="surface-line-group" style="position: absolute; inset: 0; pointer-events: none;">
        <img id="char-surface-line" style="position: absolute; left: 50%; top: 0; transform: translateX(-50%); max-width: none;">
    </div>
    <div id="hand-l-group" style="position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;">
        <div id="hand-l-transform" style="position: absolute; inset: 0; display: grid; place-items: center; transform-origin: center center;">
            <img id="char-hand-l" style="grid-area: 1/1; max-width: none;">
        </div>
    </div>
    <div id="hand-r-group" style="position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;">
        <div id="hand-r-transform" style="position: absolute; inset: 0; display: grid; place-items: center; transform-origin: center center;">
            <img id="char-hand-r" style="grid-area: 1/1; max-width: none;">
        </div>
    </div>
</div>

<div id="editor-container"></div>

<script type="module">
  import { CharacterAnimator } from "{{ url_for('static', filename='js/character_animator.js') }}";
  import { CharacterEditor } from "{{ url_for('static', filename='js/character_editor.js') }}";

  function getPreviousEventEndTime(events, clickedTime) {
      if (!Array.isArray(events) || events.length === 0) {
          return 0;
      }

      let previousEvent = null;
      events.forEach((event) => {
          const startTime = Number(event?.start_time);
          if (!Number.isFinite(startTime) || startTime > clickedTime) {
              return;
          }
          if (!previousEvent || startTime >= Number(previousEvent.start_time)) {
              previousEvent = event;
          }
      });

      if (!previousEvent) {
          return 0;
      }

      const endTime = Number(previousEvent.end_time);
      if (Number.isFinite(endTime)) {
          return endTime;
      }
      const startTime = Number(previousEvent.start_time);
      return Number.isFinite(startTime) ? startTime : 0;
  }

  function patchCharacterEditorBehavior() {
      if (CharacterEditor.__characterAnimatorPatched) {
          return;
      }
      CharacterEditor.__characterAnimatorPatched = true;

      const originalOpenEventModal = CharacterEditor.prototype._openEventModal;
      CharacterEditor.prototype._openEventModal = function(trackName, index, defaultTime = 0) {
          let resolvedDefaultTime = defaultTime;
          if (index === null) {
              const clickedTime = Number.isFinite(defaultTime) ? defaultTime : 0;
              const trackEvents = this.sequenceData?.[trackName] || [];
              resolvedDefaultTime = getPreviousEventEndTime(trackEvents, clickedTime);
          }
          return originalOpenEventModal.call(this, trackName, index, resolvedDefaultTime);
      };

      const originalRender = CharacterEditor.prototype.render;
      CharacterEditor.prototype.render = function() {
          originalRender.call(this);

          const trackElements = this.container.querySelectorAll('.editor-track');
          this.trackConfig.forEach((track, trackIndex) => {
              if (track.type !== 'BOOLEAN') {
                  return;
              }
              const trackEl = trackElements[trackIndex];
              if (!trackEl) {
                  return;
              }

              const blocks = trackEl.querySelectorAll('.event-block');
              const events = this.sequenceData[track.name] || [];
              blocks.forEach((block, eventIndex) => {
                  const boolValue = !!events[eventIndex]?.value;
                  block.style.background = boolValue ? '#b9f3c7' : '#f7c3c3';
                  block.style.color = '#2f2f2f';
              });
          });
      };
  }

  patchCharacterEditorBehavior();

  let animator = null;
  let editor = null;
  let isSequenceDirty = false;

  // DOM Elements
  const stage = document.getElementById('stage');
  const headGroup = document.getElementById('head-group');
  const handLGroup = document.getElementById('hand-l-group');
  const handRGroup = document.getElementById('hand-r-group');

  const imgHead = document.getElementById('char-head-base');
  const imgEyeL = document.getElementById('char-eye-l');
  const imgEyeR = document.getElementById('char-eye-r');
  const imgMouth = document.getElementById('char-mouth');
  const imgHandL = document.getElementById('char-hand-l');
  const imgHandR = document.getElementById('char-hand-r');
  const imgSurfaceLine = document.getElementById('char-surface-line');

  const loadBtn = document.getElementById('load-btn');
  const newSeqBtn = document.getElementById('new-seq-btn');
  const laughBtn = document.getElementById('laugh-btn');
  const laughAudioUriInput = document.getElementById('laugh-audio-uri-input');
  const saveBtn = document.getElementById('save-btn');
  const playBtn = document.getElementById('play-btn');
  const pauseBtn = document.getElementById('pause-btn');
  const seqSelect = document.getElementById('seq-select');
  const seqIdInput = document.getElementById('seq-id-input');
  const defSelect = document.getElementById('def-select');

  // Character Editor Elements
  const charEditorContainer = document.getElementById('character-editor-container');
  const charIdInput = document.getElementById('char-id-input');
  const charCreateIdRow = document.getElementById('char-create-id-row');
  const charExistingIdRow = document.getElementById('char-existing-id-row');
  const charCreateIdInput = document.getElementById('char-create-id-input');
  const charExistingIdText = document.getElementById('char-existing-id-text');
  const charNameInput = document.getElementById('char-name');
  const charWidthText = document.getElementById('char-width-text');
  const charHeightText = document.getElementById('char-height-text');
  const charHeadUriInput = document.getElementById('char-head-uri');
  const charSurfaceLineUriInput = document.getElementById('char-surface-line-uri');
  const charLeftHandUriInput = document.getElementById('char-left-hand-uri');
  const charRightHandUriInput = document.getElementById('char-right-hand-uri');
  const charMouthOpenUriInput = document.getElementById('char-mouth-open-uri');
  const charMouthClosedUriInput = document.getElementById('char-mouth-closed-uri');
  const charMouthOUriInput = document.getElementById('char-mouth-o-uri');
  const charLeftEyeOpenUriInput = document.getElementById('char-left-eye-open-uri');
  const charLeftEyeClosedUriInput = document.getElementById('char-left-eye-closed-uri');
  const charRightEyeOpenUriInput = document.getElementById('char-right-eye-open-uri');
  const charRightEyeClosedUriInput = document.getElementById('char-right-eye-closed-uri');
  const charFileIdentifierInput = document.getElementById('char-file-identifier');

  function setCharacterIdMode(isExisting) {
      charCreateIdRow.style.display = isExisting ? 'none' : 'block';
      charExistingIdRow.style.display = isExisting ? 'block' : 'none';
      charCreateIdInput.required = !isExisting;
  }

  function createEmptySequence() {
      return {
          sequence_head_transform: [],
          sequence_left_hand_transform: [],
          sequence_right_hand_transform: [],
          sequence_left_eye_open: [],
          sequence_right_eye_open: [],
          sequence_mouth_state: [],
          sequence_left_hand_visible: [],
          sequence_right_hand_visible: [],
          sequence_sound_events: [],
          sequence_surface_line_offset: [],
          sequence_mask_boundary_offset: [],
          sequence_surface_line_visible: [],
          sequence_head_masking_enabled: [],
          sequence_left_hand_masking_enabled: [],
          sequence_right_hand_masking_enabled: [],
      };
  }

  function normalizeSequenceData(sequence) {
      const normalized = createEmptySequence();
      const source = sequence || {};
      Object.keys(normalized).forEach((trackName) => {
          normalized[trackName] = Array.isArray(source[trackName]) ? source[trackName] : [];
      });
      return normalized;
  }

  function setSequenceDirty(isDirty) {
      isSequenceDirty = isDirty;
  }

  function confirmDiscardSequenceChanges() {
      if (!isSequenceDirty) {
          return true;
      }
      return confirm('Start over and discard unsaved sequence changes?');
  }

  function setPlaybackButtonsEnabled(isEnabled) {
      playBtn.disabled = !isEnabled;
      pauseBtn.disabled = !isEnabled;
  }

  function setSequenceIdState(sequenceId, isExisting) {
      seqIdInput.value = sequenceId || '';
      seqIdInput.disabled = isExisting;
  }

  function ensureSequenceOption(sequenceId) {
      if (!sequenceId) {
          return;
      }
      const exists = Array.from(seqSelect.options).some((option) => option.value === sequenceId);
      if (exists) {
          return;
      }
      const option = document.createElement('option');
      option.value = sequenceId;
      option.textContent = sequenceId;
      seqSelect.appendChild(option);
  }

  function getDomElements() {
      return {
        head: headGroup,
        headClip: headGroup,
        headTransform: document.getElementById('head-transform'),
        mouth: imgMouth,
        leftEye: imgEyeL,
        rightEye: imgEyeR,
        leftHand: handLGroup,
        leftHandClip: handLGroup,
        leftHandTransform: document.getElementById('hand-l-transform'),
        rightHand: handRGroup,
        rightHandClip: handRGroup,
        rightHandTransform: document.getElementById('hand-r-transform'),
        surfaceLine: imgSurfaceLine,
      };
  }

  function toBrowserUrl(uri) {
      if (!uri) {
          return '';
      }
      const raw = String(uri).trim();
      if (!raw) {
          return '';
      }
      if (raw.startsWith('http://') || raw.startsWith('https://') || raw.startsWith('data:')) {
          return raw;
      }
      if (!raw.startsWith('gs://')) {
          return raw;
      }

      const gcsPath = raw.slice('gs://'.length);
      const slashIndex = gcsPath.indexOf('/');
      if (slashIndex === -1) {
          return `https://${gcsPath}`;
      }
      const bucket = gcsPath.slice(0, slashIndex);
      const objectPath = gcsPath.slice(slashIndex + 1);
      if (bucket.includes('.')) {
          return `https://${bucket}/${objectPath}`;
      }
      return `https://storage.googleapis.com/${bucket}/${objectPath}`;
  }

  async function fetchAnimatorData(payload) {
      const resp = await fetch('/admin/api/character-animator/data', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
      });
      if (resp.ok) {
          return resp.json();
      }

      let message = 'Request failed';
      try {
          const errorData = await resp.json();
          message = errorData.error || message;
      } catch (_err) {
          message = await resp.text();
      }
      throw new Error(message);
  }

  async function fetchDefinition(defId) {
      const data = await fetchAnimatorData({ def_id: defId });
      if (!data.definition) {
          throw new Error('Character definition not found');
      }
      return data.definition;
  }

  document.getElementById('edit-char-btn').addEventListener('click', () => {
      const isHidden = charEditorContainer.style.display === 'none';
      charEditorContainer.style.display = isHidden ? 'block' : 'none';
      if (isHidden) {
          loadCharacterDefinitionIntoForm();
      }
  });

  defSelect.addEventListener('change', () => {
      if (charEditorContainer.style.display !== 'none') {
          loadCharacterDefinitionIntoForm();
      }
  });

  async function loadCharacterDefinitionIntoForm() {
      const defId = defSelect.value;
      if (!defId) {
          clearCharacterForm();
          return;
      }

      try {
          const def = await fetchDefinition(defId);
          populateCharacterForm(def);
      } catch (e) {
          console.error(e);
          alert('Error loading character: ' + e.message);
      }
  }

  function populateCharacterForm(def) {
      charIdInput.value = def.key || '';
      charCreateIdInput.value = '';
      charExistingIdText.textContent = def.key || '';
      setCharacterIdMode(true);
      charNameInput.value = def.name || '';
      charWidthText.textContent = def.width ?? '';
      charHeightText.textContent = def.height ?? '';
      charHeadUriInput.value = def.head_gcs_uri || '';
      charSurfaceLineUriInput.value = def.surface_line_gcs_uri;
      charLeftHandUriInput.value = def.left_hand_gcs_uri || '';
      charRightHandUriInput.value = def.right_hand_gcs_uri || '';
      charMouthOpenUriInput.value = def.mouth_open_gcs_uri || '';
      charMouthClosedUriInput.value = def.mouth_closed_gcs_uri || '';
      charMouthOUriInput.value = def.mouth_o_gcs_uri || '';
      charLeftEyeOpenUriInput.value = def.left_eye_open_gcs_uri || '';
      charLeftEyeClosedUriInput.value = def.left_eye_closed_gcs_uri || '';
      charRightEyeOpenUriInput.value = def.right_eye_open_gcs_uri || '';
      charRightEyeClosedUriInput.value = def.right_eye_closed_gcs_uri || '';
  }

  function clearCharacterForm() {
      charIdInput.value = '';
      charCreateIdInput.value = '';
      charExistingIdText.textContent = '';
      setCharacterIdMode(false);
      charNameInput.value = '';
      charWidthText.textContent = '';
      charHeightText.textContent = '';
      charHeadUriInput.value = '';
      charSurfaceLineUriInput.value = '';
      charLeftHandUriInput.value = '';
      charRightHandUriInput.value = '';
      charMouthOpenUriInput.value = '';
      charMouthClosedUriInput.value = '';
      charMouthOUriInput.value = '';
      charLeftEyeOpenUriInput.value = '';
      charLeftEyeClosedUriInput.value = '';
      charRightEyeOpenUriInput.value = '';
      charRightEyeClosedUriInput.value = '';
      charFileIdentifierInput.value = '';
  }

  document.getElementById('fill-uris-btn').addEventListener('click', (e) => {
      e.preventDefault();
      const fileIdentifier = charFileIdentifierInput.value.trim();
      if (!fileIdentifier) {
          alert('Please enter a file identifier.');
          return;
      }

      const baseUri = `gs://images.quillsstorybook.com/_joke_assets/characters/${fileIdentifier}`;
      charHeadUriInput.value = `${baseUri}/${fileIdentifier}_head.png`;
      charLeftHandUriInput.value = `${baseUri}/${fileIdentifier}_hand_left.png`;
      charRightHandUriInput.value = `${baseUri}/${fileIdentifier}_hand_right.png`;
      charMouthOpenUriInput.value = `${baseUri}/${fileIdentifier}_mouth_open.png`;
      charMouthClosedUriInput.value = `${baseUri}/${fileIdentifier}_mouth_closed.png`;
      charMouthOUriInput.value = `${baseUri}/${fileIdentifier}_mouth_o.png`;
      charLeftEyeOpenUriInput.value = `${baseUri}/${fileIdentifier}_eye_left_open.png`;
      charLeftEyeClosedUriInput.value = `${baseUri}/${fileIdentifier}_eye_left_closed.png`;
      charRightEyeOpenUriInput.value = `${baseUri}/${fileIdentifier}_eye_right_open.png`;
      charRightEyeClosedUriInput.value = `${baseUri}/${fileIdentifier}_eye_right_closed.png`;

      const surfaceLineUri = charSurfaceLineUriInput.value.trim();
      if (!surfaceLineUri) {
          charSurfaceLineUriInput.value = 'gs://images.quillsstorybook.com/_joke_assets/characters/surface_line_orange1.png';
      }
  });

  document.getElementById('new-char-btn').addEventListener('click', (e) => {
      e.preventDefault();
      clearCharacterForm();
      defSelect.value = ""; // clear selection
  });

  document.getElementById('save-char-btn').addEventListener('click', async (e) => {
      e.preventDefault();
      const existingCharacterId = charIdInput.value.trim();
      const isExistingCharacter = !!existingCharacterId;
      const createCharacterId = charCreateIdInput.value.trim();
      if (!isExistingCharacter && !createCharacterId) {
          alert('Firestore Doc ID is required for new characters.');
          return;
      }

      const btn = e.target;
      btn.disabled = true;
      btn.textContent = 'Saving...';

      try {
          const formData = new FormData();
          formData.append('op', 'character');
          formData.append('character_id', isExistingCharacter ? existingCharacterId : createCharacterId);
          formData.append('name', charNameInput.value);
          formData.append('head_gcs_uri', charHeadUriInput.value);
          formData.append('surface_line_gcs_uri', charSurfaceLineUriInput.value);
          formData.append('left_hand_gcs_uri', charLeftHandUriInput.value);
          formData.append('right_hand_gcs_uri', charRightHandUriInput.value);
          formData.append('mouth_open_gcs_uri', charMouthOpenUriInput.value);
          formData.append('mouth_closed_gcs_uri', charMouthClosedUriInput.value);
          formData.append('mouth_o_gcs_uri', charMouthOUriInput.value);
          formData.append('left_eye_open_gcs_uri', charLeftEyeOpenUriInput.value);
          formData.append('left_eye_closed_gcs_uri', charLeftEyeClosedUriInput.value);
          formData.append('right_eye_open_gcs_uri', charRightEyeOpenUriInput.value);
          formData.append('right_eye_closed_gcs_uri', charRightEyeClosedUriInput.value);

          const resp = await fetch('/joke_creation_process', {
              method: 'POST',
              body: formData
          });

          if (!resp.ok) {
              const text = await resp.text();
              throw new Error(text);
          }

          alert('Character saved successfully!');
          if (confirm("Reload page to update list?")) {
              window.location.reload();
          }

      } catch (err) {
          console.error(err);
          alert('Error saving character: ' + err.message);
      } finally {
          btn.disabled = false;
          btn.textContent = 'Save Character';
      }
  });

  async function startSequenceEditor(definition, sequenceData, sequenceId, isExisting) {
      const normalizedSequence = normalizeSequenceData(sequenceData);
      setupStage(definition);
      initializeComponents(normalizedSequence, definition);
      setSequenceIdState(sequenceId, isExisting);
      if (!isExisting) {
          seqSelect.value = '';
      }
      setSequenceDirty(false);
  }

  async function loadExistingSequence() {
    const defId = defSelect.value;
    const seqId = seqSelect.value;

    if (!defId || !seqId) {
      alert('Please select both a definition and a sequence.');
      return;
    }
    if (!confirmDiscardSequenceChanges()) {
      return;
    }

    loadBtn.disabled = true;
    loadBtn.textContent = 'Loading...';

    try {
      const data = await fetchAnimatorData({ def_id: defId, seq_id: seqId });
      const def = data.definition;
      const seq = data.sequence;
      if (!def || !seq) {
          throw new Error('Missing definition or sequence payload');
      }

      await startSequenceEditor(def, seq, seq.key || seqId, true);

    } catch (e) {
      console.error(e);
      alert('Error loading animation: ' + e.message);
    } finally {
      loadBtn.disabled = false;
      loadBtn.textContent = 'Load';
    }
  }

  async function createNewSequence() {
      const defId = defSelect.value;
      if (!defId) {
          alert('Please select a Character Definition first.');
          return;
      }
      if (!confirmDiscardSequenceChanges()) {
          return;
      }

      newSeqBtn.disabled = true;
      newSeqBtn.textContent = 'Preparing...';

      try {
          const definition = await fetchDefinition(defId);
          await startSequenceEditor(definition, createEmptySequence(), '', false);
      } catch (e) {
          console.error(e);
          alert('Error creating new sequence: ' + e.message);
      } finally {
          newSeqBtn.disabled = false;
          newSeqBtn.textContent = 'New Sequence';
      }
  }

  async function saveSequence() {
      if (!editor) {
          alert('Load or create a sequence first.');
          return;
      }

      const seqId = seqIdInput.value.trim();
      const sequenceData = normalizeSequenceData(editor.sequenceData);

      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';

      try {
          const formData = new FormData();
          formData.append('op', 'animation');
          formData.append('sequence_data', JSON.stringify(sequenceData));
          if (seqId) {
              formData.append('sequence_id', seqId);
          }

          const resp = await fetch('/joke_creation_process', {
              method: 'POST',
              body: formData
          });

          if (!resp.ok) {
              const text = await resp.text();
              throw new Error(text);
          }

          const result = await resp.json();
          const savedSeq = result.data;

          alert('Sequence saved successfully!');
          if (savedSeq.key) {
              setSequenceIdState(savedSeq.key, true);
              ensureSequenceOption(savedSeq.key);
              seqSelect.value = savedSeq.key;
              setSequenceDirty(false);
          }

          if (confirm("Reload page to update list?")) {
              window.location.reload();
          }

      } catch (e) {
          console.error(e);
          alert('Error saving: ' + e.message);
      } finally {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Sequence';
      }
  }

  async function applyLaughSequence() {
      if (!editor || !animator) {
          alert('Load or create a sequence first.');
          return;
      }

      const audioGcsUri = laughAudioUriInput.value.trim();
      if (!audioGcsUri) {
          alert('Please enter a laugh audio GCS URI.');
          return;
      }

      const shouldOverwrite = confirm(
          'Overwrite all timeline tracks with a generated laugh sequence?'
      );
      if (!shouldOverwrite) {
          return;
      }

      laughBtn.disabled = true;
      const originalText = laughBtn.textContent;
      laughBtn.textContent = 'Generating...';

      try {
          const formData = new FormData();
          formData.append('op', 'animation_laugh');
          formData.append('audio_gcs_uri', audioGcsUri);

          const resp = await fetch('/joke_creation_process', {
              method: 'POST',
              body: formData
          });

          if (!resp.ok) {
              const text = await resp.text();
              throw new Error(text);
          }

          const result = await resp.json();
          const generatedSequence = normalizeSequenceData(result.data || {});

          editor.sequenceData = generatedSequence;
          editor.render();
          await animator.updateSequence(generatedSequence);
          animator.seek(0);
          setSequenceDirty(true);
      } catch (e) {
          console.error(e);
          alert('Error generating laugh sequence: ' + e.message);
      } finally {
          laughBtn.disabled = false;
          laughBtn.textContent = originalText;
      }
  }

  loadBtn.addEventListener('click', loadExistingSequence);
  newSeqBtn.addEventListener('click', createNewSequence);
  laughBtn.addEventListener('click', applyLaughSequence);
  saveBtn.addEventListener('click', saveSequence);
  playBtn.addEventListener('click', () => animator?.play());
  pauseBtn.addEventListener('click', () => animator?.pause());

  function setupStage(def) {
      stage.style.width = `${def.width}px`;
      stage.style.height = `${def.height}px`;

      imgHead.src = toBrowserUrl(def.head_gcs_uri);
      imgHandL.src = toBrowserUrl(def.left_hand_gcs_uri);
      imgHandR.src = toBrowserUrl(def.right_hand_gcs_uri);
      imgSurfaceLine.src = toBrowserUrl(def.surface_line_gcs_uri);

      imgEyeL.src = toBrowserUrl(def.left_eye_open_gcs_uri);
      imgEyeR.src = toBrowserUrl(def.right_eye_open_gcs_uri);
      imgMouth.src = toBrowserUrl(def.mouth_closed_gcs_uri);
      imgSurfaceLine.style.top = `${(def.height || 0) - 50}px`;
      imgSurfaceLine.style.opacity = '1';
  }

  function initializeComponents(seq, def) {
      if (animator) {
          animator.pause();
      }
      if (editor) {
          editor.destroy();
      }

      setPlaybackButtonsEnabled(false);
      animator = new CharacterAnimator(seq, getDomElements(), def);
      animator.init().then(() => {
          setPlaybackButtonsEnabled(true);
      }).catch((err) => {
          console.error(err);
          alert('Error initializing animator: ' + err.message);
      });

      const container = document.getElementById('editor-container');
      editor = new CharacterEditor(container, seq, (updatedSeq) => {
          setSequenceDirty(true);
          if (animator) {
              animator.updateSequence(updatedSeq);
              animator.seek(0);
          }
      });
  }

  setPlaybackButtonsEnabled(false);
</script>
{% endblock %}
