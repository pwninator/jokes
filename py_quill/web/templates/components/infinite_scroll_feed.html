{% macro infinite_scroll_feed(slug, initial_jokes=None, initial_cursor=None, initial_has_more=None, width=450, feed_id=None, cursor_storage_key=None, end_of_feed_message=None, extra_query_params=None, admin_mode=false, grid_enabled=false) -%}
{% from "components/joke_card.html" import joke_card with context %}
{% set feed_id = feed_id or ('jokes-feed-' + slug) %}
{% set loading_id = feed_id + '-loading' %}
{% set end_of_feed_id = feed_id + '-end' %}
{% set sentinel_id = feed_id + '-sentinel' %}

<style>
  .{{ feed_id }} {
    display: grid;
    {% if grid_enabled %}
    grid-template-columns: repeat(auto-fit, minmax(min(100%, {{ width }}px), 1fr));
    gap: 0.5rem;
    {% else %}
    grid-template-columns: 1fr;
    gap: 2rem;
    {% endif %}
    margin: 0 auto;
    justify-items: center;
  }

  .{{ feed_id }} .joke-card {
    width: 100%;
  }

  .{{ feed_id }} .joke-slide-media img {
    width: 100%;
    height: auto;
    aspect-ratio: 1 / 1;
    object-fit: cover;
  }

  .loading-indicator {
    text-align: center;
    padding: 2rem;
    color: #666;
    min-height: 60px;
    display: none;
  }

  .loading-indicator.active {
    display: block;
  }

  .end-of-feed {
    text-align: center;
    padding: 2rem;
    color: #666;
    display: none;
  }

  .end-of-feed.active {
    display: block;
  }
</style>

<section class="{{ feed_id }}" id="{{ feed_id }}" aria-label="Jokes feed">
  {% if initial_jokes %}
    {% for entry in initial_jokes %}
    {{ joke_card(entry.joke, reveal_label='Reveal Punchline', width=width, joke_id=entry.joke.key, feed_cursor=entry.cursor, admin_mode=admin_mode) }}
    {% endfor %}
  {% endif %}
</section>
<div class="loading-indicator" id="{{ loading_id }}" aria-live="polite">
  Loading more...
</div>
{% if end_of_feed_message %}
<div class="end-of-feed" id="{{ end_of_feed_id }}" aria-live="polite">
  {{ end_of_feed_message }}
</div>
{% endif %}

<script>
  (function () {
    const feedContainer = document.getElementById('{{ feed_id }}');
    const loadingIndicator = document.getElementById('{{ loading_id }}');
    const endOfFeed = document.getElementById('{{ end_of_feed_id }}');
    const cursorStorageKey = {{ cursor_storage_key | tojson if cursor_storage_key else 'null' }};
    const extraQueryParams = {{ extra_query_params | tojson if extra_query_params else 'null' }};
    const apiEndpoint = '/jokes/feed/load-more-{{ slug }}';

    function applyExtraQueryParams(url) {
      if (!extraQueryParams) {
        return;
      }
      try {
        for (const [key, value] of Object.entries(extraQueryParams)) {
          if (value === null || value === undefined) {
            continue;
          }
          const strValue = String(value);
          if (!strValue) {
            continue;
          }
          url.searchParams.set(key, strValue);
        }
      } catch (e) {
        // Ignore.
      }
    }

    function setLocalStorage(name, value) {
      try {
        localStorage.setItem(name, value);
      } catch (e) {
        // localStorage may be blocked/unavailable or full; fail silently.
      }
    }

    function getLocalStorage(name) {
      if (!name) {
        return null;
      }
      try {
        return localStorage.getItem(name);
      } catch (e) {
        return null;
      }
    }

    function parseCursor(value) {
      if (!value || typeof value !== 'string') {
        return null;
      }
      const parts = value.split(':', 2);
      if (parts.length !== 2) {
        return null;
      }
      const docId = parts[0];
      const index = Number.parseInt(parts[1], 10);
      if (!docId || Number.isNaN(index)) {
        return null;
      }
      return { docId, index };
    }

    function isCursorBefore(current, target) {
      const targetCursor = parseCursor(target);
      if (!targetCursor) {
        return false;
      }
      const currentCursor = parseCursor(current);
      if (!currentCursor) {
        return true;
      }
      if (currentCursor.docId === targetCursor.docId) {
        return currentCursor.index < targetCursor.index;
      }
      return currentCursor.docId < targetCursor.docId;
    }

    function maybeAdvanceCursor(eventTarget) {
      if (!cursorStorageKey) {
        return;
      }
      const card = eventTarget.closest('[data-feed-cursor]');
      if (!card) {
        return;
      }
      const targetCursor = card.dataset.feedCursor;
      if (!targetCursor) {
        return;
      }
      const currentCursor = getLocalStorage(cursorStorageKey);
      if (isCursorBefore(currentCursor, targetCursor)) {
        setLocalStorage(cursorStorageKey, targetCursor);
      }
    }

    if (feedContainer) {
      feedContainer.addEventListener('click', (event) => {
        const revealButton = event.target.closest('[data-role="reveal"]');
        if (!revealButton) {
          return;
        }
        maybeAdvanceCursor(revealButton);
      });
    }

    {% if initial_jokes is none %}
    // No initial jokes - start empty and load immediately
    let nextCursor = null;
    let hasMore = true;
    let isLoading = false;

    // Load immediately on page load
    function loadMoreJokes() {
      if (isLoading || !hasMore) {
        return;
      }

      isLoading = true;
      loadingIndicator.classList.add('active');

      const url = new URL(apiEndpoint, window.location.origin);
      if (nextCursor) {
        url.searchParams.set('cursor', nextCursor);
      }
      applyExtraQueryParams(url);

      fetch(url)
        .then(response => response.json())
        .then(data => {
          if (data.html) {
            const temp = document.createElement('div');
            temp.innerHTML = data.html;

            const cards = temp.querySelectorAll('.joke-card');
            cards.forEach(card => {
              feedContainer.appendChild(card);
              const viewer = card.querySelector('[data-joke-viewer]');
              if (viewer && window.initJokeViewer) {
                window.initJokeViewer(viewer);
              }
            });
          }

          nextCursor = data.cursor;
          hasMore = data.has_more;

          if (!hasMore) {
            if (endOfFeed) {
              endOfFeed.classList.add('active');
            }
            if (observer) {
              observer.unobserve(sentinel);
            }
          } else if (nextCursor) {
            if (observer) {
              observer.observe(sentinel);
            }
          }
        })
        .catch(error => {
          console.error('Error loading more jokes:', error);
        })
        .finally(() => {
          isLoading = false;
          loadingIndicator.classList.remove('active');
        });
    }

    // Create sentinel for intersection observer
    const sentinel = document.createElement('div');
    sentinel.id = '{{ sentinel_id }}';
    sentinel.style.height = '1px';
    sentinel.style.width = '100%';
    sentinel.setAttribute('aria-hidden', 'true');
    feedContainer.parentNode.insertBefore(sentinel, loadingIndicator);

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && hasMore && !isLoading && nextCursor) {
          loadMoreJokes();
        }
      });
    }, {
      rootMargin: '200px',
      threshold: 0
    });

    // Load first page immediately
    loadMoreJokes();

    // Set up observer for subsequent loads
    if (nextCursor) {
      observer.observe(sentinel);
    }
    {% else %}
    // Initial jokes provided - use them
    // Always use initial_cursor (which points to the NEXT batch after initial_jokes)
    // Cursor persistence/resume is handled client-side via localStorage.
    const initialNextCursor = {{ initial_cursor | tojson if initial_cursor else 'null' }};
    const initialHasMore = {{ initial_has_more | tojson if initial_has_more is not none else (initial_cursor is not none) | tojson }};
    let nextCursor = initialNextCursor;
    let hasMore = initialHasMore;
    let isLoading = false;

    const savedCursor = cursorStorageKey ? getLocalStorage(cursorStorageKey) : null;
    const isResuming = Boolean(savedCursor) && document.documentElement.classList.contains('feed-resuming');

    if (!isResuming && (!hasMore || !nextCursor) && endOfFeed) {
      endOfFeed.classList.add('active');
    }

    if (isResuming) {
      // Prevent the normal infinite-scroll machinery from firing while we resume.
      nextCursor = null;
      hasMore = false;
    }

    function loadMoreJokes() {
      if (isLoading || !hasMore || !nextCursor) {
        return;
      }

      isLoading = true;
      loadingIndicator.classList.add('active');

      const url = new URL(apiEndpoint, window.location.origin);
      url.searchParams.set('cursor', nextCursor);
      applyExtraQueryParams(url);

      fetch(url)
        .then(response => response.json())
        .then(data => {
          if (data.html) {
            const temp = document.createElement('div');
            temp.innerHTML = data.html;

            const cards = temp.querySelectorAll('.joke-card');
            cards.forEach(card => {
              feedContainer.appendChild(card);
              const viewer = card.querySelector('[data-joke-viewer]');
              if (viewer && window.initJokeViewer) {
                window.initJokeViewer(viewer);
              }
            });
          }

          nextCursor = data.cursor;
          hasMore = data.has_more;

          if (!hasMore) {
            if (endOfFeed) {
              endOfFeed.classList.add('active');
            }
            observer.unobserve(sentinel);
          } else if (nextCursor) {
            observer.observe(sentinel);
          }
        })
        .catch(error => {
          console.error('Error loading more jokes:', error);
        })
        .finally(() => {
          isLoading = false;
          loadingIndicator.classList.remove('active');
        });
    }

    // Create sentinel for intersection observer
    const sentinel = document.createElement('div');
    sentinel.id = '{{ sentinel_id }}';
    sentinel.style.height = '1px';
    sentinel.style.width = '100%';
    sentinel.setAttribute('aria-hidden', 'true');
    feedContainer.parentNode.insertBefore(sentinel, loadingIndicator);

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && hasMore && !isLoading && nextCursor) {
          loadMoreJokes();
        }
      });
    }, {
      rootMargin: '200px',
      threshold: 0
    });

    function enableObserverIfNeeded() {
      if (hasMore && nextCursor) {
        observer.observe(sentinel);
      }
    }

    function disableObserver() {
      try {
        observer.unobserve(sentinel);
      } catch (e) {
        // Ignore.
      }
    }

    function resumeFromCursor(cursor) {
      if (!cursor || !feedContainer) {
        document.documentElement.classList.remove('feed-resuming');
        return;
      }

      isLoading = true;

      const url = new URL(apiEndpoint, window.location.origin);
      url.searchParams.set('cursor', cursor);
      applyExtraQueryParams(url);

      fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error(`Resume fetch failed: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          if (data.html) {
            // Replace the server-rendered jokes (never shown) with resumed jokes.
            feedContainer.innerHTML = '';

            const temp = document.createElement('div');
            temp.innerHTML = data.html;

            const cards = temp.querySelectorAll('.joke-card');
            cards.forEach(card => {
              feedContainer.appendChild(card);
              const viewer = card.querySelector('[data-joke-viewer]');
              if (viewer && window.initJokeViewer) {
                window.initJokeViewer(viewer);
              }
            });
          }

          nextCursor = data.cursor;
          hasMore = data.has_more;

          if ((!hasMore || !nextCursor) && endOfFeed) {
            endOfFeed.classList.add('active');
            disableObserver();
          } else {
            if (endOfFeed) {
              endOfFeed.classList.remove('active');
            }
            enableObserverIfNeeded();
          }

          document.documentElement.classList.remove('feed-resuming');
        })
        .catch(error => {
          console.error('Error resuming from cursor:', error);
          // Fallback: show the initial, server-rendered jokes.
          nextCursor = initialNextCursor;
          hasMore = initialHasMore;
          document.documentElement.classList.remove('feed-resuming');
          if ((!hasMore || !nextCursor) && endOfFeed) {
            endOfFeed.classList.add('active');
          }
          enableObserverIfNeeded();
        })
        .finally(() => {
          isLoading = false;
        });
    }

    // Observe the sentinel element for reliable scroll detection
    if (!isResuming) {
      observer.observe(sentinel);
    }

    if (isResuming) {
      resumeFromCursor(savedCursor);
    }
    {% endif %}
  })();
</script>
{%- endmacro %}
