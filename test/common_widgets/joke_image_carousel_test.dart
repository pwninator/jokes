import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:snickerdoodle/src/common_widgets/joke_image_carousel.dart';
import 'package:snickerdoodle/src/core/providers/image_providers.dart';
import 'package:snickerdoodle/src/core/services/image_service.dart';
import 'package:snickerdoodle/src/core/theme/app_theme.dart';
import 'package:snickerdoodle/src/features/jokes/data/models/joke_model.dart';
import 'package:image_test_utils/image_test_utils.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:cached_network_image/cached_network_image.dart';


import '../test_helpers/firebase_mocks.dart';
import 'joke_image_carousel_test.mocks.dart'; // Generated by build_runner

// Generate mocks for ImageService
@GenerateMocks([ImageService])
void main() {
  // Use a common MockImageService instance
  late MockImageService mockImageService;

  setUp(() {
    mockImageService = MockImageService();
    // Stubbing the methods of mockImageService
    when(mockImageService.isValidImageUrl(any)).thenAnswer((realInvocation) {
      final url = realInvocation.positionalArguments.first as String?;
      return url != null && url.startsWith('http');
    });
    when(mockImageService.processImageUrl(any)).thenAnswer((realInvocation) {
      final url = realInvocation.positionalArguments.first as String;
      return 'processed_$url'; // Simulate processing
    });
  });

  group('JokeImageCarousel Widget Tests', () {
    Widget createTestWidget({
      required Widget child,
      List<Override> additionalOverrides = const [],
    }) {
      return ProviderScope(
        overrides: [
          ...FirebaseMocks.getFirebaseProviderOverrides(),
          imageServiceProvider.overrideWithValue(mockImageService),
          ...additionalOverrides,
        ],
        child: MaterialApp(theme: lightTheme, home: Scaffold(body: child)),
      );
    }

    const testJoke = Joke(
      id: '1',
      setupText: 'Test setup',
      punchlineText: 'Test punchline',
      setupImageUrl: 'https://example.com/setup.jpg',
      punchlineImageUrl: 'https://example.com/punchline.jpg',
    );

    const testJoke2 = Joke(
      id: '2',
      setupText: 'Test setup 2',
      punchlineText: 'Test punchline 2',
      setupImageUrl: 'https://example.com/setup2.jpg',
      punchlineImageUrl: 'https://example.com/punchline2.jpg',
    );

    const testJoke3 = Joke(
      id: '3',
      setupText: 'Test setup 3',
      punchlineText: 'Test punchline 3',
      setupImageUrl: 'https://example.com/setup3.jpg',
      punchlineImageUrl: 'https://example.com/punchline3.jpg',
    );


    group('Basic Functionality', () {
      testWidgets('should display image carousel with page indicators', (
        tester,
      ) async {
        provideMockedNetworkImages(() async {
          // arrange
          const widget = JokeImageCarousel(joke: testJoke);

          // act
          await tester.pumpWidget(createTestWidget(child: widget));
          await tester.pumpAndSettle();

          // assert
          expect(find.byType(PageView), findsOneWidget);
          expect(find.byType(Card), findsOneWidget);

          final pageIndicators = find.byWidgetPredicate(
            (widget) => widget is AnimatedContainer &&
                       widget.decoration is BoxDecoration &&
                       (widget.decoration as BoxDecoration).borderRadius == BorderRadius.circular(4),
          );
          expect(pageIndicators, findsNWidgets(2));
        });
      });

      testWidgets(
        'should not show regenerate button when isAdminMode is false',
        (tester) async {
          provideMockedNetworkImages(() async {
            // arrange
            const widget = JokeImageCarousel(joke: testJoke, isAdminMode: false);

            // act
            await tester.pumpWidget(createTestWidget(child: widget));
            await tester.pumpAndSettle();

            // assert
            expect(find.text('Regenerate Images'), findsNothing);
            expect(find.byIcon(Icons.refresh), findsNothing);
          });
        },
      );

      testWidgets('should show regenerate button when isAdminMode is true', (
        tester,
      ) async {
        provideMockedNetworkImages(() async {
          // arrange
          const widget = JokeImageCarousel(joke: testJoke, isAdminMode: true);

          // act
          await tester.pumpWidget(createTestWidget(child: widget));
          await tester.pumpAndSettle();

          // assert
          expect(find.textContaining('Regenerate'), findsOneWidget);
          expect(find.byIcon(Icons.refresh), findsOneWidget);
        });
      });
    });

    group('Admin Mode Functionality', () {
      testWidgets('should have regenerate button that can be tapped', (
        tester,
      ) async {
        provideMockedNetworkImages(() async {
          // arrange
          const widget = JokeImageCarousel(joke: testJoke, isAdminMode: true);

          // act
          await tester.pumpWidget(createTestWidget(child: widget));
          await tester.pumpAndSettle();

          final refreshIcon = find.byIcon(Icons.refresh);
          expect(refreshIcon, findsOneWidget);
          expect(find.textContaining('Regenerate'), findsOneWidget);

          await tester.tap(refreshIcon);
          await tester.pump();

          // assert
          expect(refreshIcon, findsOneWidget);
        });
      });

      testWidgets('should not show error container when there is no error', (
        tester,
      ) async {
        provideMockedNetworkImages(() async {
          // arrange
          const widget = JokeImageCarousel(joke: testJoke, isAdminMode: true);

          // act
          await tester.pumpWidget(createTestWidget(child: widget));
          await tester.pumpAndSettle();

          // assert
          expect(find.byIcon(Icons.error_outline), findsNothing);
        });
      });
    });

    group('Default Parameters', () {
      testWidgets('should use default isAdminMode value of false', (
        tester,
      ) async {
        provideMockedNetworkImages(() async {
          // arrange
          const widget = JokeImageCarousel(joke: testJoke);

          // act
          await tester.pumpWidget(createTestWidget(child: widget));
          await tester.pumpAndSettle();

          // assert
          expect(find.text('Regenerate Images'), findsNothing);
        });
      });
    });

    group('Image Preloading', () {
      // This test is tricky because precacheImage is hard to mock directly.
      // We'll verify that ImageService methods are called, implying precacheImage would be.
      testWidgets(
        'should attempt to preload images for the current joke',
        (tester) async {
          provideMockedNetworkImages(() async {
            // arrange
            const widget = JokeImageCarousel(joke: testJoke);

            // act
            await tester.pumpWidget(createTestWidget(child: widget));
            // Wait for initState and post-frame callbacks
            await tester.pumpAndSettle();


            // assert
            // Verify ImageService was called for the current joke's images
            verify(mockImageService.isValidImageUrl(testJoke.setupImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.setupImageUrl!)).called(1);
            verify(mockImageService.isValidImageUrl(testJoke.punchlineImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.punchlineImageUrl!)).called(1);

            // Check that CachedNetworkImage widgets are present for the current joke
            // This indirectly confirms that preloading setup likely happened.
            expect(find.byType(CachedNetworkImage), findsNWidgets(2));
          });
        },
      );

      testWidgets(
        'should attempt to preload images for jokes in jokesToPreload',
        (tester) async {
          provideMockedNetworkImages(() async {
            // arrange
            final jokesToPreload = [testJoke2, testJoke3];
            final widget = JokeImageCarousel(joke: testJoke, jokesToPreload: jokesToPreload);

            // act
            await tester.pumpWidget(createTestWidget(child: widget));
            await tester.pumpAndSettle();

            // assert
            // Current joke
            verify(mockImageService.isValidImageUrl(testJoke.setupImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.setupImageUrl!)).called(1);
            verify(mockImageService.isValidImageUrl(testJoke.punchlineImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.punchlineImageUrl!)).called(1);

            // First joke to preload
            verify(mockImageService.isValidImageUrl(testJoke2.setupImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke2.setupImageUrl!)).called(1);
            verify(mockImageService.isValidImageUrl(testJoke2.punchlineImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke2.punchlineImageUrl!)).called(1);

            // Second joke to preload
            verify(mockImageService.isValidImageUrl(testJoke3.setupImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke3.setupImageUrl!)).called(1);
            verify(mockImageService.isValidImageUrl(testJoke3.punchlineImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke3.punchlineImageUrl!)).called(1);
          });
        },
      );


      testWidgets(
        'should handle null jokesToPreload gracefully',
        (tester) async {
          provideMockedNetworkImages(() async {
            // arrange
            const widget = JokeImageCarousel(joke: testJoke, jokesToPreload: null);

            // act
            await tester.pumpWidget(createTestWidget(child: widget));
            await tester.pumpAndSettle();

            // assert
            // Current joke only
            verify(mockImageService.isValidImageUrl(testJoke.setupImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.setupImageUrl!)).called(1);
            verify(mockImageService.isValidImageUrl(testJoke.punchlineImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.punchlineImageUrl!)).called(1);

            // Ensure no errors for others
            verifyNever(mockImageService.isValidImageUrl(testJoke2.setupImageUrl));
            expect(tester.takeException(), isNull);
          });
        },
      );

      testWidgets(
        'should handle empty jokesToPreload list gracefully',
        (tester) async {
          provideMockedNetworkImages(() async {
            // arrange
            const widget = JokeImageCarousel(joke: testJoke, jokesToPreload: []);

            // act
            await tester.pumpWidget(createTestWidget(child: widget));
            await tester.pumpAndSettle();

            // assert
            // Current joke only
            verify(mockImageService.isValidImageUrl(testJoke.setupImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.setupImageUrl!)).called(1);
            verify(mockImageService.isValidImageUrl(testJoke.punchlineImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.punchlineImageUrl!)).called(1);

            verifyNever(mockImageService.isValidImageUrl(testJoke2.setupImageUrl));
            expect(tester.takeException(), isNull);
          });
        },
      );


      testWidgets(
        'should handle jokes with null image URLs in jokesToPreload gracefully',
        (tester) async {
          provideMockedNetworkImages(() async {
            // arrange
            const jokeWithNullImages = Joke(
              id: '4',
              setupText: 'Test setup 4',
              punchlineText: 'Test punchline 4',
              setupImageUrl: null,
              punchlineImageUrl: null,
            );
            final jokesToPreload = [jokeWithNullImages];
            final widget = JokeImageCarousel(joke: testJoke, jokesToPreload: jokesToPreload);

            // act
            await tester.pumpWidget(createTestWidget(child: widget));
            await tester.pumpAndSettle();

            // assert
            // Current joke
            verify(mockImageService.isValidImageUrl(testJoke.setupImageUrl)).called(1);
            verify(mockImageService.processImageUrl(testJoke.setupImageUrl!)).called(1);
            // For jokeWithNullImages, isValidImageUrl should be called, but processImageUrl should not.
            verify(mockImageService.isValidImageUrl(jokeWithNullImages.setupImageUrl)).called(1);
            verifyNever(mockImageService.processImageUrl(captureAny)); // Ensure processImageUrl is not called for nulls

            expect(tester.takeException(), isNull);
          });
        },
      );
    });

    group('Tap Behavior', () {
      testWidgets(
        'should call onSetupTap when setup image is tapped and callback is provided',
        (tester) async {
          // arrange
          bool setupTapCalled = false;
          final widget = JokeImageCarousel(
            joke: testJoke,
            onSetupTap: () => setupTapCalled = true,
          );

          // act
          await tester.pumpWidget(createTestWidget(child: widget));
          await tester.pump();

          // Tap on the GestureDetector (which covers the entire carousel)
          await tester.tap(find.byType(GestureDetector));
          await tester.pump();

          // assert
          expect(setupTapCalled, isTrue);
        },
      );

      testWidgets(
        'should call onPunchlineTap when punchline image is tapped and callback is provided',
        (tester) async {
          // arrange
          bool punchlineTapCalled = false;
          final widget = JokeImageCarousel(
            joke: testJoke,
            onPunchlineTap: () => punchlineTapCalled = true,
          );

          // act
          await tester.pumpWidget(createTestWidget(child: widget));
          await tester.pump();

          // First tap should navigate to punchline (default behavior)
          await tester.tap(find.byType(GestureDetector));
          await tester.pump();
          // Use pump with specific duration instead of pumpAndSettle to avoid timeout
          await tester.pump(const Duration(milliseconds: 400));

          // Second tap should call the punchline callback
          await tester.tap(find.byType(GestureDetector));
          await tester.pump();

          // assert
          expect(punchlineTapCalled, isTrue);
        },
      );

      testWidgets('should handle taps when no callbacks are provided', (
        tester,
      ) async {
        // arrange
        const widget = JokeImageCarousel(joke: testJoke);

        // act
        await tester.pumpWidget(createTestWidget(child: widget));
        await tester.pump();

        // First tap should not cause any exceptions (should navigate to punchline)
        await tester.tap(find.byType(GestureDetector));
        await tester.pump();
        await tester.pump(const Duration(milliseconds: 400));

        // Second tap should also not cause exceptions (should navigate back to setup)
        await tester.tap(find.byType(GestureDetector));
        await tester.pump();
        await tester.pump(const Duration(milliseconds: 400));

        // assert - no exceptions
        expect(tester.takeException(), isNull);
        expect(find.byType(PageView), findsOneWidget);
      });

      testWidgets('should navigate between pages with default tap behavior', (
        tester,
      ) async {
        // arrange
        const widget = JokeImageCarousel(joke: testJoke);

        // act
        await tester.pumpWidget(createTestWidget(child: widget));
        await tester.pump();

        // Tap to go to punchline
        await tester.tap(find.byType(GestureDetector));
        await tester.pump(const Duration(milliseconds: 400));

        // Tap again to go back to setup
        await tester.tap(find.byType(GestureDetector));
        await tester.pump(const Duration(milliseconds: 400));

        // assert - widget should still be functioning correctly
        expect(find.byType(PageView), findsOneWidget);
        expect(tester.takeException(), isNull);
      });
    });
  });
}
